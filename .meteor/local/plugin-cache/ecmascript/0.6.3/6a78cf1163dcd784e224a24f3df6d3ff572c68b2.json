{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/client/vendor/dragdealer.js","filenameRelative":"/client/vendor/dragdealer.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/client/vendor/dragdealer.js.map","sourceFileName":"/client/vendor/dragdealer.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"dragdealer"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Dragdealer.js 0.9.8\n * http://github.com/skidding/dragdealer\n *\n * (c) 2010+ Ovidiu Chereche»ô\n * http://skidding.mit-license.org\n */(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else if ((typeof module === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(module)) === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports.Dragdealer = factory();\n  } else {\n    // Browser globals\n    root.Dragdealer = factory();\n  }\n})(this, function () {\n  var Dragdealer = function (wrapper, options) {\n    /**\n     * Drag-based component that works around two basic DOM elements.\n     *\n     *   - The wrapper: The top-level element with the .dragdealer class. We\n     *                  create a Dragdealer instance with the wrapper as the\n     *                  first constructor parameter (it can either receive the ID\n     *                  of the wrapper, or the element itself.) The wrapper\n     *                  establishes the dragging bounds.\n     *\n     *   - The handle: A child of the wrapper element, div with a required\n     *                 .handle class (may be overridden in options). This will be\n     *                 the dragged element, constrained by the wrapper's bounds.\n     *\n     *\n     * The handle can be both smaller or bigger than the wrapper.\n     *\n     *   - When the handle is smaller, Dragdealer will act as a regular slider,\n     *     enabling the handle to be dragged from one side of the wrapper to\n     *     another.\n     *\n     *   - When the handle is bigger, Dragdealer will act a mask for a draggable\n     *     surface, where the handle is the draggable surface contrained by the\n     *     smaller bounds of the wrapper. The drag action in this case is used\n     *     to reveal and \"discover\" partial content at a time.\n     *\n     *\n     * Simple usage:\n     *\n     *   // JavaScript\n     *   new Dragdealer('simple-slider');\n     *\n     *   <!-- HTML -->\n     *   <div id=\"simple-slider\" class=\"dragdealer\">\n     *     <div class=\"handle\">drag me</div>\n     *   </div>\n     *\n     *\n     * The second parameter of the Dragdealer constructor is an object used for\n     * specifying any of the supported options. All of them are optional.\n     *\n     *   - bool disabled=false: Init Dragdealer in a disabled state. The handle\n     *                          will have a .disabled class.\n     *\n     *   - bool horizontal=true: Enable horizontal dragging.\n     *\n     *   - bool vertical=false: Enable vertical dragging.\n     *\n     *   - number x=0: Initial horizontal (left) position. Accepts a float number\n     *                 value between 0 and 1. Read below about positioning in\n     *                 Dragdealer.\n     *\n     *   - number y=0: Initial vertical (top) position. Accepts a float number\n     *                 value between 0 and 1. Read below about positoning in\n     *                 Dragdealer.\n     *\n     *   - number steps=0: Limit the positioning of the handle within the bounds\n     *                     of the wrapper, by defining a virtual grid made out of\n     *                     a number of equally-spaced steps. This restricts\n     *                     placing the handle anywhere in-between these steps.\n     *                     E.g. setting 3 steps to a regular slider will only\n     *                     allow you to move it to the left, to the right or\n     *                     exactly in the middle.\n     *\n     *   - bool snap=false: When a number of steps is set, snap the position of\n     *                      the handle to its closest step instantly, even when\n     *                      dragging.\n     *\n     *   - number speed=0.1: Speed can be set between 0 and 1, with 1 being the\n     *                       fastest. It represents how fast the handle will slide\n     *                       to position after you mouse up.\n     *\n     *   - bool slide=true: Slide handle after releasing it, depending on the\n     *                      movement speed before the mouse/touch release. The\n     *                      formula for calculating how much will the handle\n     *                      slide after releasing it is defined by simply\n     *                      extending the movement of the handle in the current\n     *                      direction, with the last movement unit times four (a\n     *                      movement unit is considered the distance crossed\n     *                      since the last animation loop, which is currently\n     *                      25ms.) So if you were to drag the handle 50px in the\n     *                      blink of an eye, it will slide another 200px in the\n     *                      same direction. Steps interfere with this formula, as\n     *                      the closest step is calculated before the sliding\n     *                      distance.\n     *\n     *   - bool loose=false: Loosen-up wrapper boundaries when dragging. This\n     *                       allows the handle to be *slightly* dragged outside\n     *                       the bounds of the wrapper, but slides it back to the\n     *                       margins of the wrapper upon release. The formula for\n     *                       calculating how much the handle exceeds the wrapper\n     *                       bounds is made out of the actual drag distance\n     *                       divided by 4. E.g. Pulling a slider outside its\n     *                       frame by 100px will only position it 25px outside\n     *                       the frame.\n     *\n     *   - number top=0: Top padding between the wrapper and the handle.\n     *\n     *   - number bottom=0: Bottom padding between the wrapper and the handle.\n     *\n     *   - number left=0: Left padding between the wrapper and the handle.\n     *\n     *   - number right=0: Right padding between the wrapper and the handle.\n     *\n     *   - fn callback(x, y): Called when releasing handle, with the projected\n     *                        x, y position of the handle. Projected value means\n     *                        the value the slider will have after finishing a\n     *                        sliding animation, caused by either a step\n     *                        restriction or drag motion (see steps and slide\n     *                        options.) This implies that the actual position of\n     *                        the handle at the time this callback is called\n     *                        might not yet reflect the x, y values received.\n     *\n     *   - fn dragStopCallback(x,y): Same as callback(x,y) but only called after\n     *                               a drag motion, not after setting the step\n     *                               manually.\n     *\n     *   - fn dragStartCallback(x,y): Same as dragStopCallback(x,y) but called at\n     *                                the beginning of a drag motion and with the\n     *                                sliders initial x, y values.\n     *\n     *   - fn animationCallback(x, y): Called every animation loop, as long as\n     *                                 the handle is being dragged or in the\n     *                                 process of a sliding animation. The x, y\n     *                                 positional values received by this\n     *                                 callback reflect the exact position of the\n     *                                 handle DOM element, which includes\n     *                                 exceeding values (even negative values)\n     *                                 when the loose option is set true.\n     *\n     *   - string handleClass='handle': Custom class of handle element.\n     *\n     *   - bool css3=true: Use css3 transform in modern browsers instead of\n     *                     absolute positioning.\n     *\n     *   - fn customRequestAnimationFrame: Provide custom requestAnimationFrame\n     *                                     function (used in tests).\n     *   - fn customCancelAnimationFrame: Provide custom cancelAnimationFrame\n     *                                    function (used in tests).\n     *\n     * Dragdealer also has a few methods to interact with, post-initialization.\n     *\n     *   - disable: Disable dragging of a Dragdealer instance. Just as with the\n     *              disabled option, the handle will receive a .disabled class\n     *\n     *   - enable: Enable dragging of a Dragdealer instance. The .disabled class\n     *             of the handle will be removed.\n     *\n     *   - reflow: Recalculate the wrapper bounds of a Dragdealer instance, used\n     *             when the wrapper is responsive and its parent container\n     *             changed its size, or after changing the size of the wrapper\n     *             directly.\n     *\n     *   - getValue: Get the value of a Dragdealer instance programatically. The\n     *               value is returned as an [x, y] tuple and is the equivalent\n     *               of the (projected) value returned by the regular callback,\n     *               not animationCallback.\n     *\n     *   - getStep: Same as getValue, but the value returned is in step\n     *              increments (see steps option)\n     *\n     *   - setValue(x, y, snap=false): Set the value of a Dragdealer instance\n     *                                 programatically. The 3rd parameter allows\n     *                                 to snap the handle directly to the desired\n     *                                 value, without any sliding transition.\n     *\n     *   - setStep(x, y, snap=false): Same as setValue, but the value is received\n     *                                in step increments (see steps option)\n     *\n     *\n     * Positioning in Dragdealer:\n     *\n     *   Besides the top, bottom, left and right paddings, which represent a\n     *   number of pixels, Dragdealer uses a [0, 1]-based positioning. Both\n     *   horizontal and vertical positions are represented by ratios between 0\n     *   and 1. This allows the Dragdealer wrapper to have a responsive size and\n     *   not revolve around a specific number of pixels. This is how the x, y\n     *   options are set, what the callback args contain and what values the\n     *   setValue method expects. Once picked up, the ratios can be scaled and\n     *   mapped to match any real-life system of coordinates or dimensions.\n     */this.options = this.applyDefaults(options || {});\n    this.bindMethods();\n    this.wrapper = this.getWrapperElement(wrapper);\n\n    if (!this.wrapper) {\n      return;\n    }\n\n    this.handle = this.getHandleElement(this.wrapper, this.options.handleClass);\n\n    if (!this.handle) {\n      return;\n    }\n\n    this.init();\n    this.bindEventListeners();\n  };\n\n  Dragdealer.prototype = {\n    defaults: {\n      disabled: false,\n      horizontal: true,\n      vertical: false,\n      slide: true,\n      steps: 0,\n      snap: false,\n      loose: false,\n      speed: 0.1,\n      xPrecision: 0,\n      yPrecision: 0,\n      handleClass: 'handle',\n      css3: true,\n      activeClass: 'active',\n      tapping: true\n    },\n    init: function () {\n      if (this.options.css3) {\n        triggerWebkitHardwareAcceleration(this.handle);\n      }\n\n      this.value = {\n        prev: [-1, -1],\n        current: [this.options.x || 0, this.options.y || 0],\n        target: [this.options.x || 0, this.options.y || 0]\n      };\n      this.offset = {\n        wrapper: [0, 0],\n        mouse: [0, 0],\n        prev: [-999999, -999999],\n        current: [0, 0],\n        target: [0, 0]\n      };\n      this.dragStartPosition = {\n        x: 0,\n        y: 0\n      };\n      this.change = [0, 0];\n      this.stepRatios = this.calculateStepRatios();\n      this.activity = false;\n      this.dragging = false;\n      this.tapping = false;\n      this.reflow();\n\n      if (this.options.disabled) {\n        this.disable();\n      }\n    },\n    applyDefaults: function (options) {\n      for (var k in meteorBabelHelpers.sanitizeForInObject(this.defaults)) {\n        if (!options.hasOwnProperty(k)) {\n          options[k] = this.defaults[k];\n        }\n      }\n\n      return options;\n    },\n    getWrapperElement: function (wrapper) {\n      if (typeof wrapper == 'string') {\n        return document.getElementById(wrapper);\n      } else {\n        return wrapper;\n      }\n    },\n    getHandleElement: function (wrapper, handleClass) {\n      var childElements, handleClassMatcher, i;\n\n      if (wrapper.getElementsByClassName) {\n        childElements = wrapper.getElementsByClassName(handleClass);\n\n        if (childElements.length > 0) {\n          return childElements[0];\n        }\n      } else {\n        handleClassMatcher = new RegExp('(^|\\\\s)' + handleClass + '(\\\\s|$)');\n        childElements = wrapper.getElementsByTagName('*');\n\n        for (i = 0; i < childElements.length; i++) {\n          if (handleClassMatcher.test(childElements[i].className)) {\n            return childElements[i];\n          }\n        }\n      }\n    },\n    calculateStepRatios: function () {\n      var stepRatios = [];\n\n      if (this.options.steps >= 1) {\n        for (var i = 0; i <= this.options.steps - 1; i++) {\n          if (this.options.steps > 1) {\n            stepRatios[i] = i / (this.options.steps - 1);\n          } else {\n            // A single step will always have a 0 value\n            stepRatios[i] = 0;\n          }\n        }\n      }\n\n      return stepRatios;\n    },\n    setWrapperOffset: function () {\n      this.offset.wrapper = Position.get(this.wrapper);\n    },\n    calculateBounds: function () {\n      // Apply top/bottom/left and right padding options to wrapper extremities\n      // when calculating its bounds\n      var bounds = {\n        top: this.options.top || 0,\n        bottom: -(this.options.bottom || 0) + this.wrapper.offsetHeight,\n        left: this.options.left || 0,\n        right: -(this.options.right || 0) + this.wrapper.offsetWidth\n      }; // The available width and height represents the horizontal and vertical\n      // space the handle has for moving. It is determined by the width and\n      // height of the wrapper, minus the width and height of the handle\n\n      bounds.availWidth = bounds.right - bounds.left - this.handle.offsetWidth;\n      bounds.availHeight = bounds.bottom - bounds.top - this.handle.offsetHeight;\n      return bounds;\n    },\n    calculateValuePrecision: function () {\n      // The sliding transition works by dividing itself until it reaches a min\n      // value step; because Dragdealer works with [0-1] values, we need this\n      // \"min value step\" to represent a pixel when applied to the real handle\n      // position within the DOM. The xPrecision/yPrecision options can be\n      // specified to increase the granularity when we're controlling larger\n      // objects from one of the callbacks\n      var xPrecision = this.options.xPrecision || Math.abs(this.bounds.availWidth),\n          yPrecision = this.options.yPrecision || Math.abs(this.bounds.availHeight);\n      return [xPrecision ? 1 / xPrecision : 0, yPrecision ? 1 / yPrecision : 0];\n    },\n    bindMethods: function () {\n      if (typeof this.options.customRequestAnimationFrame === 'function') {\n        this.requestAnimationFrame = bind(this.options.customRequestAnimationFrame, window);\n      } else {\n        this.requestAnimationFrame = bind(requestAnimationFrame, window);\n      }\n\n      if (typeof this.options.customCancelAnimationFrame === 'function') {\n        this.cancelAnimationFrame = bind(this.options.customCancelAnimationFrame, window);\n      } else {\n        this.cancelAnimationFrame = bind(cancelAnimationFrame, window);\n      }\n\n      this.animateWithRequestAnimationFrame = bind(this.animateWithRequestAnimationFrame, this);\n      this.animate = bind(this.animate, this);\n      this.onHandleMouseDown = bind(this.onHandleMouseDown, this);\n      this.onHandleTouchStart = bind(this.onHandleTouchStart, this);\n      this.onDocumentMouseMove = bind(this.onDocumentMouseMove, this);\n      this.onWrapperTouchMove = bind(this.onWrapperTouchMove, this);\n      this.onWrapperMouseDown = bind(this.onWrapperMouseDown, this);\n      this.onWrapperTouchStart = bind(this.onWrapperTouchStart, this);\n      this.onDocumentMouseUp = bind(this.onDocumentMouseUp, this);\n      this.onDocumentTouchEnd = bind(this.onDocumentTouchEnd, this);\n      this.onHandleClick = bind(this.onHandleClick, this);\n      this.onWindowResize = bind(this.onWindowResize, this);\n    },\n    bindEventListeners: function () {\n      // Start dragging\n      addEventListener(this.handle, 'mousedown', this.onHandleMouseDown);\n      addEventListener(this.handle, 'touchstart', this.onHandleTouchStart); // While dragging\n\n      addEventListener(document, 'mousemove', this.onDocumentMouseMove);\n      addEventListener(this.wrapper, 'touchmove', this.onWrapperTouchMove); // Start tapping\n\n      addEventListener(this.wrapper, 'mousedown', this.onWrapperMouseDown);\n      addEventListener(this.wrapper, 'touchstart', this.onWrapperTouchStart); // Stop dragging/tapping\n\n      addEventListener(document, 'mouseup', this.onDocumentMouseUp);\n      addEventListener(document, 'touchend', this.onDocumentTouchEnd);\n      addEventListener(this.handle, 'click', this.onHandleClick);\n      addEventListener(window, 'resize', this.onWindowResize);\n      this.animate(false, true);\n      this.interval = this.requestAnimationFrame(this.animateWithRequestAnimationFrame);\n    },\n    unbindEventListeners: function () {\n      removeEventListener(this.handle, 'mousedown', this.onHandleMouseDown);\n      removeEventListener(this.handle, 'touchstart', this.onHandleTouchStart);\n      removeEventListener(document, 'mousemove', this.onDocumentMouseMove);\n      removeEventListener(this.wrapper, 'touchmove', this.onWrapperTouchMove);\n      removeEventListener(this.wrapper, 'mousedown', this.onWrapperMouseDown);\n      removeEventListener(this.wrapper, 'touchstart', this.onWrapperTouchStart);\n      removeEventListener(document, 'mouseup', this.onDocumentMouseUp);\n      removeEventListener(document, 'touchend', this.onDocumentTouchEnd);\n      removeEventListener(this.handle, 'click', this.onHandleClick);\n      removeEventListener(window, 'resize', this.onWindowResize);\n      this.cancelAnimationFrame(this.interval);\n    },\n    onHandleMouseDown: function (e) {\n      Cursor.refresh(e);\n      preventEventDefaults(e);\n      stopEventPropagation(e);\n      this.activity = false;\n      this.startDrag();\n    },\n    onHandleTouchStart: function (e) {\n      Cursor.refresh(e); // Unlike in the `mousedown` event handler, we don't prevent defaults here,\n      // because this would disable the dragging altogether. Instead, we prevent\n      // it in the `touchmove` handler. Read more about touch events\n      // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Touch_events#Handling_clicks\n\n      stopEventPropagation(e);\n      this.activity = false;\n      this.startDrag();\n    },\n    onDocumentMouseMove: function (e) {\n      if (e.clientX - this.dragStartPosition.x === 0 && e.clientY - this.dragStartPosition.y === 0) {\n        // This is required on some Windows8 machines that get mouse move events without actual mouse movement\n        return;\n      }\n\n      Cursor.refresh(e);\n\n      if (this.dragging) {\n        this.activity = true;\n        preventEventDefaults(e);\n      }\n    },\n    onWrapperTouchMove: function (e) {\n      Cursor.refresh(e); // Dragging on a disabled axis (horizontal or vertical) shouldn't prevent\n      // defaults on touch devices. !this.activity denotes this is the first move\n      // inside a drag action; you can drag in any direction after this point if\n      // the dragging wasn't stopped\n\n      if (!this.activity && this.draggingOnDisabledAxis()) {\n        if (this.dragging) {\n          this.stopDrag();\n        }\n\n        return;\n      } // Read comment in `onHandleTouchStart` above, to understand why we're\n      // preventing defaults here and not there\n\n\n      preventEventDefaults(e);\n      this.activity = true;\n    },\n    onWrapperMouseDown: function (e) {\n      Cursor.refresh(e);\n      preventEventDefaults(e);\n      this.startTap();\n    },\n    onWrapperTouchStart: function (e) {\n      Cursor.refresh(e);\n      preventEventDefaults(e);\n      this.startTap();\n    },\n    onDocumentMouseUp: function (e) {\n      this.stopDrag();\n      this.stopTap();\n    },\n    onDocumentTouchEnd: function (e) {\n      this.stopDrag();\n      this.stopTap();\n    },\n    onHandleClick: function (e) {\n      // We keep track if any dragging activity has been made between the\n      // mouse/touch down and up events; based on this we allow or cancel a click\n      // event from inside the handle. i.e. Click events shouldn't be triggered\n      // when dragging, but should be allowed when clicking still\n      if (this.activity) {\n        preventEventDefaults(e);\n        stopEventPropagation(e);\n      }\n    },\n    onWindowResize: function (e) {\n      this.reflow();\n    },\n    enable: function () {\n      this.disabled = false;\n      this.handle.className = this.handle.className.replace(/\\s?disabled/g, '');\n    },\n    disable: function () {\n      this.disabled = true;\n      this.handle.className += ' disabled';\n    },\n    reflow: function () {\n      this.setWrapperOffset();\n      this.bounds = this.calculateBounds();\n      this.valuePrecision = this.calculateValuePrecision();\n      this.updateOffsetFromValue();\n    },\n    getStep: function () {\n      return [this.getStepNumber(this.value.target[0]), this.getStepNumber(this.value.target[1])];\n    },\n    getStepWidth: function () {\n      return Math.abs(this.bounds.availWidth / this.options.steps);\n    },\n    getValue: function () {\n      return this.value.target;\n    },\n    setStep: function (x, y, snap) {\n      this.setValue(this.options.steps && x > 1 ? (x - 1) / (this.options.steps - 1) : 0, this.options.steps && y > 1 ? (y - 1) / (this.options.steps - 1) : 0, snap);\n    },\n    setValue: function (x, y, snap) {\n      this.setTargetValue([x, y || 0]);\n\n      if (snap) {\n        this.groupCopy(this.value.current, this.value.target); // Since the current value will be equal to the target one instantly, the\n        // animate function won't get to run so we need to update the positions\n        // and call the callbacks manually\n\n        this.updateOffsetFromValue();\n        this.callAnimationCallback();\n      }\n    },\n    startTap: function () {\n      if (this.disabled || !this.options.tapping) {\n        return;\n      }\n\n      this.tapping = true;\n      this.setWrapperOffset();\n      this.setTargetValueByOffset([Cursor.x - this.offset.wrapper[0] - this.handle.offsetWidth / 2, Cursor.y - this.offset.wrapper[1] - this.handle.offsetHeight / 2]);\n    },\n    stopTap: function () {\n      if (this.disabled || !this.tapping) {\n        return;\n      }\n\n      this.tapping = false;\n      this.setTargetValue(this.value.current);\n    },\n    startDrag: function () {\n      if (this.disabled) {\n        return;\n      }\n\n      this.dragging = true;\n      this.setWrapperOffset();\n      this.dragStartPosition = {\n        x: Cursor.x,\n        y: Cursor.y\n      };\n      this.offset.mouse = [Cursor.x - Position.get(this.handle)[0], Cursor.y - Position.get(this.handle)[1]];\n\n      if (!this.wrapper.className.match(this.options.activeClass)) {\n        this.wrapper.className += ' ' + this.options.activeClass;\n      }\n\n      this.callDragStartCallback();\n    },\n    stopDrag: function () {\n      if (this.disabled || !this.dragging) {\n        return;\n      }\n\n      this.dragging = false;\n      var deltaX = this.bounds.availWidth === 0 ? 0 : (Cursor.x - this.dragStartPosition.x) / this.bounds.availWidth,\n          deltaY = this.bounds.availHeight === 0 ? 0 : (Cursor.y - this.dragStartPosition.y) / this.bounds.availHeight,\n          delta = [deltaX, deltaY];\n      var target = this.groupClone(this.value.current);\n\n      if (this.options.slide) {\n        var ratioChange = this.change;\n        target[0] += ratioChange[0] * 4;\n        target[1] += ratioChange[1] * 4;\n      }\n\n      this.setTargetValue(target);\n      this.wrapper.className = this.wrapper.className.replace(' ' + this.options.activeClass, '');\n      this.callDragStopCallback(delta);\n    },\n    callAnimationCallback: function () {\n      var value = this.value.current;\n\n      if (this.options.snap && this.options.steps > 1) {\n        value = this.getClosestSteps(value);\n      }\n\n      if (!this.groupCompare(value, this.value.prev)) {\n        if (typeof this.options.animationCallback == 'function') {\n          this.options.animationCallback.call(this, value[0], value[1]);\n        }\n\n        this.groupCopy(this.value.prev, value);\n      }\n    },\n    callTargetCallback: function () {\n      if (typeof this.options.callback == 'function') {\n        this.options.callback.call(this, this.value.target[0], this.value.target[1]);\n      }\n    },\n    callDragStartCallback: function () {\n      if (typeof this.options.dragStartCallback == 'function') {\n        this.options.dragStartCallback.call(this, this.value.target[0], this.value.target[1]);\n      }\n    },\n    callDragStopCallback: function (delta) {\n      if (typeof this.options.dragStopCallback == 'function') {\n        this.options.dragStopCallback.call(this, this.value.target[0], this.value.target[1], delta);\n      }\n    },\n    animateWithRequestAnimationFrame: function (time) {\n      if (time) {\n        // using requestAnimationFrame\n        this.timeOffset = this.timeStamp ? time - this.timeStamp : 0;\n        this.timeStamp = time;\n      } else {\n        // using setTimeout(callback, 25) polyfill\n        this.timeOffset = 25;\n      }\n\n      this.animate();\n      this.interval = this.requestAnimationFrame(this.animateWithRequestAnimationFrame);\n    },\n    animate: function (direct, first) {\n      if (direct && !this.dragging) {\n        return;\n      }\n\n      if (this.dragging) {\n        var prevTarget = this.groupClone(this.value.target);\n        var offset = [Cursor.x - this.offset.wrapper[0] - this.offset.mouse[0], Cursor.y - this.offset.wrapper[1] - this.offset.mouse[1]];\n        this.setTargetValueByOffset(offset, this.options.loose);\n        this.change = [this.value.target[0] - prevTarget[0], this.value.target[1] - prevTarget[1]];\n      }\n\n      if (this.dragging || first) {\n        this.groupCopy(this.value.current, this.value.target);\n      }\n\n      if (this.dragging || this.glide() || first) {\n        this.updateOffsetFromValue();\n        this.callAnimationCallback();\n      }\n    },\n    glide: function () {\n      var diff = [this.value.target[0] - this.value.current[0], this.value.target[1] - this.value.current[1]];\n\n      if (!diff[0] && !diff[1]) {\n        return false;\n      }\n\n      if (Math.abs(diff[0]) > this.valuePrecision[0] || Math.abs(diff[1]) > this.valuePrecision[1]) {\n        this.value.current[0] += diff[0] * Math.min(this.options.speed * this.timeOffset / 25, 1);\n        this.value.current[1] += diff[1] * Math.min(this.options.speed * this.timeOffset / 25, 1);\n      } else {\n        this.groupCopy(this.value.current, this.value.target);\n      }\n\n      return true;\n    },\n    updateOffsetFromValue: function () {\n      if (!this.options.snap) {\n        this.offset.current = this.getOffsetsByRatios(this.value.current);\n      } else {\n        this.offset.current = this.getOffsetsByRatios(this.getClosestSteps(this.value.current));\n      }\n\n      if (!this.groupCompare(this.offset.current, this.offset.prev)) {\n        this.renderHandlePosition();\n        this.groupCopy(this.offset.prev, this.offset.current);\n      }\n    },\n    renderHandlePosition: function () {\n      var transform = '';\n\n      if (this.options.css3 && StylePrefix.transform) {\n        if (this.options.horizontal) {\n          transform += 'translateX(' + this.offset.current[0] + 'px)';\n        }\n\n        if (this.options.vertical) {\n          transform += ' translateY(' + this.offset.current[1] + 'px)';\n        }\n\n        this.handle.style[StylePrefix.transform] = transform;\n        return;\n      }\n\n      if (this.options.horizontal) {\n        this.handle.style.left = this.offset.current[0] + 'px';\n      }\n\n      if (this.options.vertical) {\n        this.handle.style.top = this.offset.current[1] + 'px';\n      }\n    },\n    setTargetValue: function (value, loose) {\n      var target = loose ? this.getLooseValue(value) : this.getProperValue(value);\n      this.groupCopy(this.value.target, target);\n      this.offset.target = this.getOffsetsByRatios(target);\n      this.callTargetCallback();\n    },\n    setTargetValueByOffset: function (offset, loose) {\n      var value = this.getRatiosByOffsets(offset);\n      var target = loose ? this.getLooseValue(value) : this.getProperValue(value);\n      this.groupCopy(this.value.target, target);\n      this.offset.target = this.getOffsetsByRatios(target);\n    },\n    getLooseValue: function (value) {\n      var proper = this.getProperValue(value);\n      return [proper[0] + (value[0] - proper[0]) / 4, proper[1] + (value[1] - proper[1]) / 4];\n    },\n    getProperValue: function (value) {\n      var proper = this.groupClone(value);\n      proper[0] = Math.max(proper[0], 0);\n      proper[1] = Math.max(proper[1], 0);\n      proper[0] = Math.min(proper[0], 1);\n      proper[1] = Math.min(proper[1], 1);\n\n      if (!this.dragging && !this.tapping || this.options.snap) {\n        if (this.options.steps > 1) {\n          proper = this.getClosestSteps(proper);\n        }\n      }\n\n      return proper;\n    },\n    getRatiosByOffsets: function (group) {\n      return [this.getRatioByOffset(group[0], this.bounds.availWidth, this.bounds.left), this.getRatioByOffset(group[1], this.bounds.availHeight, this.bounds.top)];\n    },\n    getRatioByOffset: function (offset, range, padding) {\n      return range ? (offset - padding) / range : 0;\n    },\n    getOffsetsByRatios: function (group) {\n      return [this.getOffsetByRatio(group[0], this.bounds.availWidth, this.bounds.left), this.getOffsetByRatio(group[1], this.bounds.availHeight, this.bounds.top)];\n    },\n    getOffsetByRatio: function (ratio, range, padding) {\n      return Math.round(ratio * range) + padding;\n    },\n    getStepNumber: function (value) {\n      // Translate a [0-1] value into a number from 1 to N steps (set using the\n      // \"steps\" option)\n      return this.getClosestStep(value) * (this.options.steps - 1) + 1;\n    },\n    getClosestSteps: function (group) {\n      return [this.getClosestStep(group[0]), this.getClosestStep(group[1])];\n    },\n    getClosestStep: function (value) {\n      var k = 0;\n      var min = 1;\n\n      for (var i = 0; i <= this.options.steps - 1; i++) {\n        if (Math.abs(this.stepRatios[i] - value) < min) {\n          min = Math.abs(this.stepRatios[i] - value);\n          k = i;\n        }\n      }\n\n      return this.stepRatios[k];\n    },\n    groupCompare: function (a, b) {\n      return a[0] == b[0] && a[1] == b[1];\n    },\n    groupCopy: function (a, b) {\n      a[0] = b[0];\n      a[1] = b[1];\n    },\n    groupClone: function (a) {\n      return [a[0], a[1]];\n    },\n    draggingOnDisabledAxis: function () {\n      return !this.options.horizontal && Cursor.xDiff > Cursor.yDiff || !this.options.vertical && Cursor.yDiff > Cursor.xDiff;\n    }\n  };\n\n  var bind = function (fn, context) {\n    /**\n     * CoffeeScript-like function to bind the scope of a method to an instance,\n     * the context of that method, regardless from where it is called\n     */return function () {\n      return fn.apply(context, arguments);\n    };\n  }; // Cross-browser vanilla JS event handling\n\n\n  var addEventListener = function (element, type, callback) {\n    if (element.addEventListener) {\n      element.addEventListener(type, callback, false);\n    } else if (element.attachEvent) {\n      element.attachEvent('on' + type, callback);\n    }\n  };\n\n  var removeEventListener = function (element, type, callback) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type, callback, false);\n    } else if (element.detachEvent) {\n      element.detachEvent('on' + type, callback);\n    }\n  };\n\n  var preventEventDefaults = function (e) {\n    if (!e) {\n      e = window.event;\n    }\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n\n    e.returnValue = false;\n  };\n\n  var stopEventPropagation = function (e) {\n    if (!e) {\n      e = window.event;\n    }\n\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    }\n\n    e.cancelBubble = true;\n  };\n\n  var Cursor = {\n    /**\n     * Abstraction for making the combined mouse or touch position available at\n     * any time.\n     *\n     * It picks up the \"move\" events as an independent component and simply makes\n     * the latest x and y mouse/touch position of the user available at any time,\n     * which is requested with Cursor.x and Cursor.y respectively.\n     *\n     * It can receive both mouse and touch events consecutively, extracting the\n     * relevant meta data from each type of event.\n     *\n     * Cursor.refresh(e) is called to update the global x and y values, with a\n     * genuine MouseEvent or a TouchEvent from an event listener, e.g.\n     * mousedown/up or touchstart/end\n     */x: 0,\n    y: 0,\n    xDiff: 0,\n    yDiff: 0,\n    refresh: function (e) {\n      if (!e) {\n        e = window.event;\n      }\n\n      if (e.type == 'mousemove') {\n        this.set(e);\n      } else if (e.touches) {\n        this.set(e.touches[0]);\n      }\n    },\n    set: function (e) {\n      var lastX = this.x,\n          lastY = this.y;\n\n      if (e.clientX || e.clientY) {\n        this.x = e.clientX;\n        this.y = e.clientY;\n      } else if (e.pageX || e.pageY) {\n        this.x = e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft;\n        this.y = e.pageY - document.body.scrollTop - document.documentElement.scrollTop;\n      }\n\n      this.xDiff = Math.abs(this.x - lastX);\n      this.yDiff = Math.abs(this.y - lastY);\n    }\n  };\n  var Position = {\n    /**\n     * Helper for extracting position of a DOM element, relative to the viewport\n     *\n     * The get(obj) method accepts a DOM element as the only parameter, and\n     * returns the position under a (x, y) tuple, as an array with two elements.\n     */get: function (obj) {\n      // Dragdealer relies on getBoundingClientRect to calculate element offsets,\n      // but we want to be sure we don't throw any unhandled exceptions and break\n      // other code from the page if running from in very old browser that doesn't\n      // support this method\n      var rect = {\n        left: 0,\n        top: 0\n      };\n\n      if (obj.getBoundingClientRect !== undefined) {\n        rect = obj.getBoundingClientRect();\n      }\n\n      return [rect.left, rect.top];\n    }\n  };\n  var StylePrefix = {\n    transform: getPrefixedStylePropName('transform'),\n    perspective: getPrefixedStylePropName('perspective'),\n    backfaceVisibility: getPrefixedStylePropName('backfaceVisibility')\n  };\n\n  function getPrefixedStylePropName(propName) {\n    var domPrefixes = 'Webkit Moz ms O'.split(' '),\n        elStyle = document.documentElement.style;\n    if (elStyle[propName] !== undefined) return propName; // Is supported unprefixed\n\n    propName = propName.charAt(0).toUpperCase() + propName.substr(1);\n\n    for (var i = 0; i < domPrefixes.length; i++) {\n      if (elStyle[domPrefixes[i] + propName] !== undefined) {\n        return domPrefixes[i] + propName; // Is supported with prefix\n      }\n    }\n  }\n\n  ;\n\n  function triggerWebkitHardwareAcceleration(element) {\n    if (StylePrefix.backfaceVisibility && StylePrefix.perspective) {\n      element.style[StylePrefix.perspective] = '1000px';\n      element.style[StylePrefix.backfaceVisibility] = 'hidden';\n    }\n  }\n\n  ;\n  var vendors = ['webkit', 'moz'];\n  var requestAnimationFrame = window.requestAnimationFrame;\n  var cancelAnimationFrame = window.cancelAnimationFrame;\n\n  for (var x = 0; x < vendors.length && !requestAnimationFrame; ++x) {\n    requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!requestAnimationFrame) {\n    requestAnimationFrame = function (callback) {\n      return setTimeout(callback, 25);\n    };\n\n    cancelAnimationFrame = clearTimeout;\n  }\n\n  return Dragdealer;\n});","ast":null,"map":{"version":3,"sources":["/client/vendor/dragdealer.js"],"names":["root","factory","define","amd","module","exports","Dragdealer","wrapper","options","applyDefaults","bindMethods","getWrapperElement","handle","getHandleElement","handleClass","init","bindEventListeners","prototype","defaults","disabled","horizontal","vertical","slide","steps","snap","loose","speed","xPrecision","yPrecision","css3","activeClass","tapping","triggerWebkitHardwareAcceleration","value","prev","current","x","y","target","offset","mouse","dragStartPosition","change","stepRatios","calculateStepRatios","activity","dragging","reflow","disable","k","hasOwnProperty","document","getElementById","childElements","handleClassMatcher","i","getElementsByClassName","length","RegExp","getElementsByTagName","test","className","setWrapperOffset","Position","get","calculateBounds","bounds","top","bottom","offsetHeight","left","right","offsetWidth","availWidth","availHeight","calculateValuePrecision","Math","abs","customRequestAnimationFrame","requestAnimationFrame","bind","window","customCancelAnimationFrame","cancelAnimationFrame","animateWithRequestAnimationFrame","animate","onHandleMouseDown","onHandleTouchStart","onDocumentMouseMove","onWrapperTouchMove","onWrapperMouseDown","onWrapperTouchStart","onDocumentMouseUp","onDocumentTouchEnd","onHandleClick","onWindowResize","addEventListener","interval","unbindEventListeners","removeEventListener","e","Cursor","refresh","preventEventDefaults","stopEventPropagation","startDrag","clientX","clientY","draggingOnDisabledAxis","stopDrag","startTap","stopTap","enable","replace","valuePrecision","updateOffsetFromValue","getStep","getStepNumber","getStepWidth","getValue","setStep","setValue","setTargetValue","groupCopy","callAnimationCallback","setTargetValueByOffset","match","callDragStartCallback","deltaX","deltaY","delta","groupClone","ratioChange","callDragStopCallback","getClosestSteps","groupCompare","animationCallback","call","callTargetCallback","callback","dragStartCallback","dragStopCallback","time","timeOffset","timeStamp","direct","first","prevTarget","glide","diff","min","getOffsetsByRatios","renderHandlePosition","transform","StylePrefix","style","getLooseValue","getProperValue","getRatiosByOffsets","proper","max","group","getRatioByOffset","range","padding","getOffsetByRatio","ratio","round","getClosestStep","a","b","xDiff","yDiff","fn","context","apply","arguments","element","type","attachEvent","detachEvent","event","preventDefault","returnValue","stopPropagation","cancelBubble","set","touches","lastX","lastY","pageX","pageY","body","scrollLeft","documentElement","scrollTop","obj","rect","getBoundingClientRect","undefined","getPrefixedStylePropName","perspective","backfaceVisibility","propName","domPrefixes","split","elStyle","charAt","toUpperCase","substr","vendors","setTimeout","clearTimeout"],"mappings":"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","file":"/client/vendor/dragdealer.js.map","sourcesContent":["/**\n * Dragdealer.js 0.9.8\n * http://github.com/skidding/dragdealer\n *\n * (c) 2010+ Ovidiu Chereche»ô\n * http://skidding.mit-license.org\n */\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports.Dragdealer = factory();\n  } else {\n    // Browser globals\n    root.Dragdealer = factory();\n  }\n}(this, function () {\n\nvar Dragdealer = function(wrapper, options) {\n  /**\n   * Drag-based component that works around two basic DOM elements.\n   *\n   *   - The wrapper: The top-level element with the .dragdealer class. We\n   *                  create a Dragdealer instance with the wrapper as the\n   *                  first constructor parameter (it can either receive the ID\n   *                  of the wrapper, or the element itself.) The wrapper\n   *                  establishes the dragging bounds.\n   *\n   *   - The handle: A child of the wrapper element, div with a required\n   *                 .handle class (may be overridden in options). This will be\n   *                 the dragged element, constrained by the wrapper's bounds.\n   *\n   *\n   * The handle can be both smaller or bigger than the wrapper.\n   *\n   *   - When the handle is smaller, Dragdealer will act as a regular slider,\n   *     enabling the handle to be dragged from one side of the wrapper to\n   *     another.\n   *\n   *   - When the handle is bigger, Dragdealer will act a mask for a draggable\n   *     surface, where the handle is the draggable surface contrained by the\n   *     smaller bounds of the wrapper. The drag action in this case is used\n   *     to reveal and \"discover\" partial content at a time.\n   *\n   *\n   * Simple usage:\n   *\n   *   // JavaScript\n   *   new Dragdealer('simple-slider');\n   *\n   *   <!-- HTML -->\n   *   <div id=\"simple-slider\" class=\"dragdealer\">\n   *     <div class=\"handle\">drag me</div>\n   *   </div>\n   *\n   *\n   * The second parameter of the Dragdealer constructor is an object used for\n   * specifying any of the supported options. All of them are optional.\n   *\n   *   - bool disabled=false: Init Dragdealer in a disabled state. The handle\n   *                          will have a .disabled class.\n   *\n   *   - bool horizontal=true: Enable horizontal dragging.\n   *\n   *   - bool vertical=false: Enable vertical dragging.\n   *\n   *   - number x=0: Initial horizontal (left) position. Accepts a float number\n   *                 value between 0 and 1. Read below about positioning in\n   *                 Dragdealer.\n   *\n   *   - number y=0: Initial vertical (top) position. Accepts a float number\n   *                 value between 0 and 1. Read below about positoning in\n   *                 Dragdealer.\n   *\n   *   - number steps=0: Limit the positioning of the handle within the bounds\n   *                     of the wrapper, by defining a virtual grid made out of\n   *                     a number of equally-spaced steps. This restricts\n   *                     placing the handle anywhere in-between these steps.\n   *                     E.g. setting 3 steps to a regular slider will only\n   *                     allow you to move it to the left, to the right or\n   *                     exactly in the middle.\n   *\n   *   - bool snap=false: When a number of steps is set, snap the position of\n   *                      the handle to its closest step instantly, even when\n   *                      dragging.\n   *\n   *   - number speed=0.1: Speed can be set between 0 and 1, with 1 being the\n   *                       fastest. It represents how fast the handle will slide\n   *                       to position after you mouse up.\n   *\n   *   - bool slide=true: Slide handle after releasing it, depending on the\n   *                      movement speed before the mouse/touch release. The\n   *                      formula for calculating how much will the handle\n   *                      slide after releasing it is defined by simply\n   *                      extending the movement of the handle in the current\n   *                      direction, with the last movement unit times four (a\n   *                      movement unit is considered the distance crossed\n   *                      since the last animation loop, which is currently\n   *                      25ms.) So if you were to drag the handle 50px in the\n   *                      blink of an eye, it will slide another 200px in the\n   *                      same direction. Steps interfere with this formula, as\n   *                      the closest step is calculated before the sliding\n   *                      distance.\n   *\n   *   - bool loose=false: Loosen-up wrapper boundaries when dragging. This\n   *                       allows the handle to be *slightly* dragged outside\n   *                       the bounds of the wrapper, but slides it back to the\n   *                       margins of the wrapper upon release. The formula for\n   *                       calculating how much the handle exceeds the wrapper\n   *                       bounds is made out of the actual drag distance\n   *                       divided by 4. E.g. Pulling a slider outside its\n   *                       frame by 100px will only position it 25px outside\n   *                       the frame.\n   *\n   *   - number top=0: Top padding between the wrapper and the handle.\n   *\n   *   - number bottom=0: Bottom padding between the wrapper and the handle.\n   *\n   *   - number left=0: Left padding between the wrapper and the handle.\n   *\n   *   - number right=0: Right padding between the wrapper and the handle.\n   *\n   *   - fn callback(x, y): Called when releasing handle, with the projected\n   *                        x, y position of the handle. Projected value means\n   *                        the value the slider will have after finishing a\n   *                        sliding animation, caused by either a step\n   *                        restriction or drag motion (see steps and slide\n   *                        options.) This implies that the actual position of\n   *                        the handle at the time this callback is called\n   *                        might not yet reflect the x, y values received.\n   *\n   *   - fn dragStopCallback(x,y): Same as callback(x,y) but only called after\n   *                               a drag motion, not after setting the step\n   *                               manually.\n   *\n   *   - fn dragStartCallback(x,y): Same as dragStopCallback(x,y) but called at\n   *                                the beginning of a drag motion and with the\n   *                                sliders initial x, y values.\n   *\n   *   - fn animationCallback(x, y): Called every animation loop, as long as\n   *                                 the handle is being dragged or in the\n   *                                 process of a sliding animation. The x, y\n   *                                 positional values received by this\n   *                                 callback reflect the exact position of the\n   *                                 handle DOM element, which includes\n   *                                 exceeding values (even negative values)\n   *                                 when the loose option is set true.\n   *\n   *   - string handleClass='handle': Custom class of handle element.\n   *\n   *   - bool css3=true: Use css3 transform in modern browsers instead of\n   *                     absolute positioning.\n   *\n   *   - fn customRequestAnimationFrame: Provide custom requestAnimationFrame\n   *                                     function (used in tests).\n   *   - fn customCancelAnimationFrame: Provide custom cancelAnimationFrame\n   *                                    function (used in tests).\n   *\n   * Dragdealer also has a few methods to interact with, post-initialization.\n   *\n   *   - disable: Disable dragging of a Dragdealer instance. Just as with the\n   *              disabled option, the handle will receive a .disabled class\n   *\n   *   - enable: Enable dragging of a Dragdealer instance. The .disabled class\n   *             of the handle will be removed.\n   *\n   *   - reflow: Recalculate the wrapper bounds of a Dragdealer instance, used\n   *             when the wrapper is responsive and its parent container\n   *             changed its size, or after changing the size of the wrapper\n   *             directly.\n   *\n   *   - getValue: Get the value of a Dragdealer instance programatically. The\n   *               value is returned as an [x, y] tuple and is the equivalent\n   *               of the (projected) value returned by the regular callback,\n   *               not animationCallback.\n   *\n   *   - getStep: Same as getValue, but the value returned is in step\n   *              increments (see steps option)\n   *\n   *   - setValue(x, y, snap=false): Set the value of a Dragdealer instance\n   *                                 programatically. The 3rd parameter allows\n   *                                 to snap the handle directly to the desired\n   *                                 value, without any sliding transition.\n   *\n   *   - setStep(x, y, snap=false): Same as setValue, but the value is received\n   *                                in step increments (see steps option)\n   *\n   *\n   * Positioning in Dragdealer:\n   *\n   *   Besides the top, bottom, left and right paddings, which represent a\n   *   number of pixels, Dragdealer uses a [0, 1]-based positioning. Both\n   *   horizontal and vertical positions are represented by ratios between 0\n   *   and 1. This allows the Dragdealer wrapper to have a responsive size and\n   *   not revolve around a specific number of pixels. This is how the x, y\n   *   options are set, what the callback args contain and what values the\n   *   setValue method expects. Once picked up, the ratios can be scaled and\n   *   mapped to match any real-life system of coordinates or dimensions.\n   */\n  this.options = this.applyDefaults(options || {});\n  this.bindMethods();\n  this.wrapper = this.getWrapperElement(wrapper);\n  if (!this.wrapper) {\n    return;\n  }\n  this.handle = this.getHandleElement(this.wrapper, this.options.handleClass);\n  if (!this.handle) {\n    return;\n  }\n  this.init();\n  this.bindEventListeners();\n};\n\n\nDragdealer.prototype = {\n  defaults: {\n    disabled: false,\n    horizontal: true,\n    vertical: false,\n    slide: true,\n    steps: 0,\n    snap: false,\n    loose: false,\n    speed: 0.1,\n    xPrecision: 0,\n    yPrecision: 0,\n    handleClass: 'handle',\n    css3: true,\n    activeClass: 'active',\n    tapping: true\n  },\n  init: function() {\n    if (this.options.css3) {\n      triggerWebkitHardwareAcceleration(this.handle);\n    }\n    this.value = {\n      prev: [-1, -1],\n      current: [this.options.x || 0, this.options.y || 0],\n      target: [this.options.x || 0, this.options.y || 0]\n    };\n    this.offset = {\n      wrapper: [0, 0],\n      mouse: [0, 0],\n      prev: [-999999, -999999],\n      current: [0, 0],\n      target: [0, 0]\n    };\n    this.dragStartPosition = {x: 0, y: 0};\n    this.change = [0, 0];\n    this.stepRatios = this.calculateStepRatios();\n\n    this.activity = false;\n    this.dragging = false;\n    this.tapping = false;\n\n    this.reflow();\n    if (this.options.disabled) {\n      this.disable();\n    }\n  },\n  applyDefaults: function(options) {\n    for (var k in this.defaults) {\n      if (!options.hasOwnProperty(k)) {\n        options[k] = this.defaults[k];\n      }\n    }\n    return options;\n  },\n  getWrapperElement: function(wrapper) {\n    if (typeof(wrapper) == 'string') {\n      return document.getElementById(wrapper);\n    } else {\n      return wrapper;\n    }\n  },\n  getHandleElement: function(wrapper, handleClass) {\n    var childElements,\n        handleClassMatcher,\n        i;\n    if (wrapper.getElementsByClassName) {\n      childElements = wrapper.getElementsByClassName(handleClass);\n      if (childElements.length > 0) {\n        return childElements[0];\n      }\n    } else {\n      handleClassMatcher = new RegExp('(^|\\\\s)' + handleClass + '(\\\\s|$)');\n      childElements = wrapper.getElementsByTagName('*');\n      for (i = 0; i < childElements.length; i++) {\n        if (handleClassMatcher.test(childElements[i].className)) {\n          return childElements[i];\n        }\n      }\n    }\n  },\n  calculateStepRatios: function() {\n    var stepRatios = [];\n    if (this.options.steps >= 1) {\n      for (var i = 0; i <= this.options.steps - 1; i++) {\n        if (this.options.steps > 1) {\n          stepRatios[i] = i / (this.options.steps - 1);\n        } else {\n          // A single step will always have a 0 value\n          stepRatios[i] = 0;\n        }\n      }\n    }\n    return stepRatios;\n  },\n  setWrapperOffset: function() {\n    this.offset.wrapper = Position.get(this.wrapper);\n  },\n  calculateBounds: function() {\n    // Apply top/bottom/left and right padding options to wrapper extremities\n    // when calculating its bounds\n    var bounds = {\n      top: this.options.top || 0,\n      bottom: -(this.options.bottom || 0) + this.wrapper.offsetHeight,\n      left: this.options.left || 0,\n      right: -(this.options.right || 0) + this.wrapper.offsetWidth\n    };\n    // The available width and height represents the horizontal and vertical\n    // space the handle has for moving. It is determined by the width and\n    // height of the wrapper, minus the width and height of the handle\n    bounds.availWidth = (bounds.right - bounds.left) - this.handle.offsetWidth;\n    bounds.availHeight = (bounds.bottom - bounds.top) - this.handle.offsetHeight;\n    return bounds;\n  },\n  calculateValuePrecision: function() {\n    // The sliding transition works by dividing itself until it reaches a min\n    // value step; because Dragdealer works with [0-1] values, we need this\n    // \"min value step\" to represent a pixel when applied to the real handle\n    // position within the DOM. The xPrecision/yPrecision options can be\n    // specified to increase the granularity when we're controlling larger\n    // objects from one of the callbacks\n    var xPrecision = this.options.xPrecision || Math.abs(this.bounds.availWidth),\n        yPrecision = this.options.yPrecision || Math.abs(this.bounds.availHeight);\n    return [\n      xPrecision ? 1 / xPrecision : 0,\n      yPrecision ? 1 / yPrecision : 0\n    ];\n  },\n  bindMethods: function() {\n    if (typeof(this.options.customRequestAnimationFrame) === 'function') {\n      this.requestAnimationFrame = bind(this.options.customRequestAnimationFrame, window);\n    } else {\n      this.requestAnimationFrame = bind(requestAnimationFrame, window);\n    }\n    if (typeof(this.options.customCancelAnimationFrame) === 'function') {\n      this.cancelAnimationFrame = bind(this.options.customCancelAnimationFrame, window);\n    } else {\n      this.cancelAnimationFrame = bind(cancelAnimationFrame, window);\n    }\n    this.animateWithRequestAnimationFrame = bind(this.animateWithRequestAnimationFrame, this);\n    this.animate = bind(this.animate, this);\n    this.onHandleMouseDown = bind(this.onHandleMouseDown, this);\n    this.onHandleTouchStart = bind(this.onHandleTouchStart, this);\n    this.onDocumentMouseMove = bind(this.onDocumentMouseMove, this);\n    this.onWrapperTouchMove = bind(this.onWrapperTouchMove, this);\n    this.onWrapperMouseDown = bind(this.onWrapperMouseDown, this);\n    this.onWrapperTouchStart = bind(this.onWrapperTouchStart, this);\n    this.onDocumentMouseUp = bind(this.onDocumentMouseUp, this);\n    this.onDocumentTouchEnd = bind(this.onDocumentTouchEnd, this);\n    this.onHandleClick = bind(this.onHandleClick, this);\n    this.onWindowResize = bind(this.onWindowResize, this);\n  },\n  bindEventListeners: function() {\n    // Start dragging\n    addEventListener(this.handle, 'mousedown', this.onHandleMouseDown);\n    addEventListener(this.handle, 'touchstart', this.onHandleTouchStart);\n    // While dragging\n    addEventListener(document, 'mousemove', this.onDocumentMouseMove);\n    addEventListener(this.wrapper, 'touchmove', this.onWrapperTouchMove);\n    // Start tapping\n    addEventListener(this.wrapper, 'mousedown', this.onWrapperMouseDown);\n    addEventListener(this.wrapper, 'touchstart', this.onWrapperTouchStart);\n    // Stop dragging/tapping\n    addEventListener(document, 'mouseup', this.onDocumentMouseUp);\n    addEventListener(document, 'touchend', this.onDocumentTouchEnd);\n\n    addEventListener(this.handle, 'click', this.onHandleClick);\n    addEventListener(window, 'resize', this.onWindowResize);\n\n    this.animate(false, true);\n    this.interval = this.requestAnimationFrame(this.animateWithRequestAnimationFrame);\n\n  },\n  unbindEventListeners: function() {\n    removeEventListener(this.handle, 'mousedown', this.onHandleMouseDown);\n    removeEventListener(this.handle, 'touchstart', this.onHandleTouchStart);\n    removeEventListener(document, 'mousemove', this.onDocumentMouseMove);\n    removeEventListener(this.wrapper, 'touchmove', this.onWrapperTouchMove);\n    removeEventListener(this.wrapper, 'mousedown', this.onWrapperMouseDown);\n    removeEventListener(this.wrapper, 'touchstart', this.onWrapperTouchStart);\n    removeEventListener(document, 'mouseup', this.onDocumentMouseUp);\n    removeEventListener(document, 'touchend', this.onDocumentTouchEnd);\n    removeEventListener(this.handle, 'click', this.onHandleClick);\n    removeEventListener(window, 'resize', this.onWindowResize);\n    this.cancelAnimationFrame(this.interval);\n  },\n  onHandleMouseDown: function(e) {\n    Cursor.refresh(e);\n    preventEventDefaults(e);\n    stopEventPropagation(e);\n    this.activity = false;\n    this.startDrag();\n  },\n  onHandleTouchStart: function(e) {\n    Cursor.refresh(e);\n    // Unlike in the `mousedown` event handler, we don't prevent defaults here,\n    // because this would disable the dragging altogether. Instead, we prevent\n    // it in the `touchmove` handler. Read more about touch events\n    // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Touch_events#Handling_clicks\n    stopEventPropagation(e);\n    this.activity = false;\n    this.startDrag();\n  },\n  onDocumentMouseMove: function(e) {\n    if ((e.clientX - this.dragStartPosition.x) === 0 &&\n        (e.clientY - this.dragStartPosition.y) === 0) {\n      // This is required on some Windows8 machines that get mouse move events without actual mouse movement\n      return;\n    }\n\n    Cursor.refresh(e);\n    if (this.dragging) {\n      this.activity = true;\n      preventEventDefaults(e);\n    }\n  },\n  onWrapperTouchMove: function(e) {\n    Cursor.refresh(e);\n    // Dragging on a disabled axis (horizontal or vertical) shouldn't prevent\n    // defaults on touch devices. !this.activity denotes this is the first move\n    // inside a drag action; you can drag in any direction after this point if\n    // the dragging wasn't stopped\n    if (!this.activity && this.draggingOnDisabledAxis()) {\n      if (this.dragging) {\n        this.stopDrag();\n      }\n      return;\n    }\n    // Read comment in `onHandleTouchStart` above, to understand why we're\n    // preventing defaults here and not there\n    preventEventDefaults(e);\n    this.activity = true;\n  },\n  onWrapperMouseDown: function(e) {\n    Cursor.refresh(e);\n    preventEventDefaults(e);\n    this.startTap();\n  },\n  onWrapperTouchStart: function(e) {\n    Cursor.refresh(e);\n    preventEventDefaults(e);\n    this.startTap();\n  },\n  onDocumentMouseUp: function(e) {\n    this.stopDrag();\n    this.stopTap();\n  },\n  onDocumentTouchEnd: function(e) {\n    this.stopDrag();\n    this.stopTap();\n  },\n  onHandleClick: function(e) {\n    // We keep track if any dragging activity has been made between the\n    // mouse/touch down and up events; based on this we allow or cancel a click\n    // event from inside the handle. i.e. Click events shouldn't be triggered\n    // when dragging, but should be allowed when clicking still\n    if (this.activity) {\n      preventEventDefaults(e);\n      stopEventPropagation(e);\n    }\n  },\n  onWindowResize: function(e) {\n    this.reflow();\n  },\n  enable: function() {\n    this.disabled = false;\n    this.handle.className = this.handle.className.replace(/\\s?disabled/g, '');\n  },\n  disable: function() {\n    this.disabled = true;\n    this.handle.className += ' disabled';\n  },\n  reflow: function() {\n    this.setWrapperOffset();\n    this.bounds = this.calculateBounds();\n    this.valuePrecision = this.calculateValuePrecision();\n    this.updateOffsetFromValue();\n  },\n  getStep: function() {\n    return [\n      this.getStepNumber(this.value.target[0]),\n      this.getStepNumber(this.value.target[1])\n    ];\n  },\n  getStepWidth: function () {\n    return Math.abs(this.bounds.availWidth / this.options.steps);\n  },\n  getValue: function() {\n    return this.value.target;\n  },\n  setStep: function(x, y, snap) {\n    this.setValue(\n      this.options.steps && x > 1 ? (x - 1) / (this.options.steps - 1) : 0,\n      this.options.steps && y > 1 ? (y - 1) / (this.options.steps - 1) : 0,\n      snap\n    );\n  },\n  setValue: function(x, y, snap) {\n    this.setTargetValue([x, y || 0]);\n    if (snap) {\n      this.groupCopy(this.value.current, this.value.target);\n      // Since the current value will be equal to the target one instantly, the\n      // animate function won't get to run so we need to update the positions\n      // and call the callbacks manually\n      this.updateOffsetFromValue();\n      this.callAnimationCallback();\n    }\n  },\n  startTap: function() {\n    if (this.disabled || !this.options.tapping) {\n      return;\n    }\n\n    this.tapping = true;\n    this.setWrapperOffset();\n\n    this.setTargetValueByOffset([\n      Cursor.x - this.offset.wrapper[0] - (this.handle.offsetWidth / 2),\n      Cursor.y - this.offset.wrapper[1] - (this.handle.offsetHeight / 2)\n    ]);\n  },\n  stopTap: function() {\n    if (this.disabled || !this.tapping) {\n      return;\n    }\n    this.tapping = false;\n\n    this.setTargetValue(this.value.current);\n  },\n  startDrag: function() {\n    if (this.disabled) {\n      return;\n    }\n    this.dragging = true;\n    this.setWrapperOffset();\n\n    this.dragStartPosition = {x: Cursor.x, y: Cursor.y};\n    this.offset.mouse = [\n      Cursor.x - Position.get(this.handle)[0],\n      Cursor.y - Position.get(this.handle)[1]\n    ];\n    if (!this.wrapper.className.match(this.options.activeClass)) {\n      this.wrapper.className += ' ' + this.options.activeClass;\n    }\n    this.callDragStartCallback();\n  },\n  stopDrag: function() {\n    if (this.disabled || !this.dragging) {\n      return;\n    }\n    this.dragging = false;\n    var deltaX = this.bounds.availWidth === 0 ? 0 :\n          ((Cursor.x - this.dragStartPosition.x) / this.bounds.availWidth),\n        deltaY = this.bounds.availHeight === 0 ? 0 :\n          ((Cursor.y - this.dragStartPosition.y) / this.bounds.availHeight),\n        delta = [deltaX, deltaY];\n\n    var target = this.groupClone(this.value.current);\n    if (this.options.slide) {\n      var ratioChange = this.change;\n      target[0] += ratioChange[0] * 4;\n      target[1] += ratioChange[1] * 4;\n    }\n    this.setTargetValue(target);\n    this.wrapper.className = this.wrapper.className.replace(' ' + this.options.activeClass, '');\n    this.callDragStopCallback(delta);\n  },\n  callAnimationCallback: function() {\n    var value = this.value.current;\n    if (this.options.snap && this.options.steps > 1) {\n      value = this.getClosestSteps(value);\n    }\n    if (!this.groupCompare(value, this.value.prev)) {\n      if (typeof(this.options.animationCallback) == 'function') {\n        this.options.animationCallback.call(this, value[0], value[1]);\n      }\n      this.groupCopy(this.value.prev, value);\n    }\n  },\n  callTargetCallback: function() {\n    if (typeof(this.options.callback) == 'function') {\n      this.options.callback.call(this, this.value.target[0], this.value.target[1]);\n    }\n  },\n  callDragStartCallback: function() {\n    if (typeof(this.options.dragStartCallback) == 'function') {\n      this.options.dragStartCallback.call(this, this.value.target[0], this.value.target[1]);\n    }\n  },\n  callDragStopCallback: function(delta) {\n    if (typeof(this.options.dragStopCallback) == 'function') {\n      this.options.dragStopCallback.call(this, this.value.target[0], this.value.target[1], delta);\n    }\n  },\n  animateWithRequestAnimationFrame: function (time) {\n    if (time) {\n      // using requestAnimationFrame\n      this.timeOffset = this.timeStamp ? time - this.timeStamp : 0;\n      this.timeStamp = time;\n    } else {\n      // using setTimeout(callback, 25) polyfill\n      this.timeOffset = 25;\n    }\n    this.animate();\n    this.interval = this.requestAnimationFrame(this.animateWithRequestAnimationFrame);\n  },\n  animate: function(direct, first) {\n    if (direct && !this.dragging) {\n      return;\n    }\n    if (this.dragging) {\n      var prevTarget = this.groupClone(this.value.target);\n\n      var offset = [\n        Cursor.x - this.offset.wrapper[0] - this.offset.mouse[0],\n        Cursor.y - this.offset.wrapper[1] - this.offset.mouse[1]\n      ];\n      this.setTargetValueByOffset(offset, this.options.loose);\n\n      this.change = [\n        this.value.target[0] - prevTarget[0],\n        this.value.target[1] - prevTarget[1]\n      ];\n    }\n    if (this.dragging || first) {\n      this.groupCopy(this.value.current, this.value.target);\n    }\n    if (this.dragging || this.glide() || first) {\n      this.updateOffsetFromValue();\n      this.callAnimationCallback();\n    }\n  },\n  glide: function() {\n    var diff = [\n      this.value.target[0] - this.value.current[0],\n      this.value.target[1] - this.value.current[1]\n    ];\n    if (!diff[0] && !diff[1]) {\n      return false;\n    }\n    if (Math.abs(diff[0]) > this.valuePrecision[0] ||\n        Math.abs(diff[1]) > this.valuePrecision[1]) {\n      this.value.current[0] += diff[0] * Math.min(this.options.speed * this.timeOffset / 25, 1);\n      this.value.current[1] += diff[1] * Math.min(this.options.speed * this.timeOffset / 25, 1);\n    } else {\n      this.groupCopy(this.value.current, this.value.target);\n    }\n    return true;\n  },\n  updateOffsetFromValue: function() {\n    if (!this.options.snap) {\n      this.offset.current = this.getOffsetsByRatios(this.value.current);\n    } else {\n      this.offset.current = this.getOffsetsByRatios(\n        this.getClosestSteps(this.value.current)\n      );\n    }\n    if (!this.groupCompare(this.offset.current, this.offset.prev)) {\n      this.renderHandlePosition();\n      this.groupCopy(this.offset.prev, this.offset.current);\n    }\n  },\n  renderHandlePosition: function() {\n\n    var transform = '';\n    if (this.options.css3 && StylePrefix.transform) {\n      if (this.options.horizontal) {\n        transform += 'translateX(' + this.offset.current[0] + 'px)';\n      }\n      if (this.options.vertical) {\n        transform += ' translateY(' + this.offset.current[1] + 'px)';\n      }\n      this.handle.style[StylePrefix.transform] = transform;\n      return;\n    }\n\n    if (this.options.horizontal) {\n      this.handle.style.left = this.offset.current[0] + 'px';\n    }\n    if (this.options.vertical) {\n      this.handle.style.top = this.offset.current[1] + 'px';\n    }\n  },\n  setTargetValue: function(value, loose) {\n    var target = loose ? this.getLooseValue(value) : this.getProperValue(value);\n\n    this.groupCopy(this.value.target, target);\n    this.offset.target = this.getOffsetsByRatios(target);\n\n    this.callTargetCallback();\n  },\n  setTargetValueByOffset: function(offset, loose) {\n    var value = this.getRatiosByOffsets(offset);\n    var target = loose ? this.getLooseValue(value) : this.getProperValue(value);\n\n    this.groupCopy(this.value.target, target);\n    this.offset.target = this.getOffsetsByRatios(target);\n  },\n  getLooseValue: function(value) {\n    var proper = this.getProperValue(value);\n    return [\n      proper[0] + ((value[0] - proper[0]) / 4),\n      proper[1] + ((value[1] - proper[1]) / 4)\n    ];\n  },\n  getProperValue: function(value) {\n    var proper = this.groupClone(value);\n\n    proper[0] = Math.max(proper[0], 0);\n    proper[1] = Math.max(proper[1], 0);\n    proper[0] = Math.min(proper[0], 1);\n    proper[1] = Math.min(proper[1], 1);\n\n    if ((!this.dragging && !this.tapping) || this.options.snap) {\n      if (this.options.steps > 1) {\n        proper = this.getClosestSteps(proper);\n      }\n    }\n    return proper;\n  },\n  getRatiosByOffsets: function(group) {\n    return [\n      this.getRatioByOffset(group[0], this.bounds.availWidth, this.bounds.left),\n      this.getRatioByOffset(group[1], this.bounds.availHeight, this.bounds.top)\n    ];\n  },\n  getRatioByOffset: function(offset, range, padding) {\n    return range ? (offset - padding) / range : 0;\n  },\n  getOffsetsByRatios: function(group) {\n    return [\n      this.getOffsetByRatio(group[0], this.bounds.availWidth, this.bounds.left),\n      this.getOffsetByRatio(group[1], this.bounds.availHeight, this.bounds.top)\n    ];\n  },\n  getOffsetByRatio: function(ratio, range, padding) {\n    return Math.round(ratio * range) + padding;\n  },\n  getStepNumber: function(value) {\n    // Translate a [0-1] value into a number from 1 to N steps (set using the\n    // \"steps\" option)\n    return this.getClosestStep(value) * (this.options.steps - 1) + 1;\n  },\n  getClosestSteps: function(group) {\n    return [\n      this.getClosestStep(group[0]),\n      this.getClosestStep(group[1])\n    ];\n  },\n  getClosestStep: function(value) {\n    var k = 0;\n    var min = 1;\n    for (var i = 0; i <= this.options.steps - 1; i++) {\n      if (Math.abs(this.stepRatios[i] - value) < min) {\n        min = Math.abs(this.stepRatios[i] - value);\n        k = i;\n      }\n    }\n    return this.stepRatios[k];\n  },\n  groupCompare: function(a, b) {\n    return a[0] == b[0] && a[1] == b[1];\n  },\n  groupCopy: function(a, b) {\n    a[0] = b[0];\n    a[1] = b[1];\n  },\n  groupClone: function(a) {\n    return [a[0], a[1]];\n  },\n  draggingOnDisabledAxis: function() {\n    return (!this.options.horizontal && Cursor.xDiff > Cursor.yDiff) ||\n           (!this.options.vertical && Cursor.yDiff > Cursor.xDiff);\n  }\n};\n\n\nvar bind = function(fn, context) {\n  /**\n   * CoffeeScript-like function to bind the scope of a method to an instance,\n   * the context of that method, regardless from where it is called\n   */\n  return function() {\n    return fn.apply(context, arguments);\n  };\n};\n\n// Cross-browser vanilla JS event handling\n\nvar addEventListener = function(element, type, callback) {\n  if (element.addEventListener) {\n    element.addEventListener(type, callback, false);\n  } else if (element.attachEvent) {\n    element.attachEvent('on' + type, callback);\n  }\n};\n\nvar removeEventListener = function(element, type, callback) {\n  if (element.removeEventListener) {\n    element.removeEventListener(type, callback, false);\n  } else if (element.detachEvent) {\n    element.detachEvent('on' + type, callback);\n  }\n};\n\nvar preventEventDefaults = function(e) {\n  if (!e) {\n    e = window.event;\n  }\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  e.returnValue = false;\n};\n\nvar stopEventPropagation = function(e) {\n  if (!e) {\n    e = window.event;\n  }\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n  e.cancelBubble = true;\n};\n\n\nvar Cursor = {\n  /**\n   * Abstraction for making the combined mouse or touch position available at\n   * any time.\n   *\n   * It picks up the \"move\" events as an independent component and simply makes\n   * the latest x and y mouse/touch position of the user available at any time,\n   * which is requested with Cursor.x and Cursor.y respectively.\n   *\n   * It can receive both mouse and touch events consecutively, extracting the\n   * relevant meta data from each type of event.\n   *\n   * Cursor.refresh(e) is called to update the global x and y values, with a\n   * genuine MouseEvent or a TouchEvent from an event listener, e.g.\n   * mousedown/up or touchstart/end\n   */\n  x: 0,\n  y: 0,\n  xDiff: 0,\n  yDiff: 0,\n  refresh: function(e) {\n    if (!e) {\n      e = window.event;\n    }\n    if (e.type == 'mousemove') {\n      this.set(e);\n    } else if (e.touches) {\n      this.set(e.touches[0]);\n    }\n  },\n  set: function(e) {\n    var lastX = this.x,\n        lastY = this.y;\n    if (e.clientX || e.clientY) {\n      this.x = e.clientX;\n      this.y = e.clientY;\n    } else if (e.pageX || e.pageY) {\n      this.x = e.pageX - document.body.scrollLeft - document.documentElement.scrollLeft;\n      this.y = e.pageY - document.body.scrollTop - document.documentElement.scrollTop;\n    }\n    this.xDiff = Math.abs(this.x - lastX);\n    this.yDiff = Math.abs(this.y - lastY);\n  }\n};\n\n\nvar Position = {\n  /**\n   * Helper for extracting position of a DOM element, relative to the viewport\n   *\n   * The get(obj) method accepts a DOM element as the only parameter, and\n   * returns the position under a (x, y) tuple, as an array with two elements.\n   */\n  get: function(obj) {\n    // Dragdealer relies on getBoundingClientRect to calculate element offsets,\n    // but we want to be sure we don't throw any unhandled exceptions and break\n    // other code from the page if running from in very old browser that doesn't\n    // support this method\n    var rect = {left: 0, top: 0};\n    if (obj.getBoundingClientRect !== undefined) {\n      rect = obj.getBoundingClientRect();\n    }\n    return [rect.left, rect.top];\n  }\n};\n\n\nvar StylePrefix = {\n  transform: getPrefixedStylePropName('transform'),\n  perspective: getPrefixedStylePropName('perspective'),\n  backfaceVisibility: getPrefixedStylePropName('backfaceVisibility')\n};\n\nfunction getPrefixedStylePropName(propName) {\n  var domPrefixes = 'Webkit Moz ms O'.split(' '),\n      elStyle = document.documentElement.style;\n  if (elStyle[propName] !== undefined) return propName; // Is supported unprefixed\n  propName = propName.charAt(0).toUpperCase() + propName.substr(1);\n  for (var i = 0; i < domPrefixes.length; i++) {\n    if (elStyle[domPrefixes[i] + propName] !== undefined) {\n      return domPrefixes[i] + propName; // Is supported with prefix\n    }\n  }\n};\n\nfunction triggerWebkitHardwareAcceleration(element) {\n  if (StylePrefix.backfaceVisibility && StylePrefix.perspective) {\n    element.style[StylePrefix.perspective] = '1000px';\n    element.style[StylePrefix.backfaceVisibility] = 'hidden';\n  }\n};\n\nvar vendors = ['webkit', 'moz'];\nvar requestAnimationFrame = window.requestAnimationFrame;\nvar cancelAnimationFrame = window.cancelAnimationFrame;\n\nfor (var x = 0; x < vendors.length && !requestAnimationFrame; ++x) {\n  requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n  cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n                         window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!requestAnimationFrame) {\n  requestAnimationFrame = function (callback) {\n    return setTimeout(callback, 25);\n  };\n  cancelAnimationFrame = clearTimeout;\n}\n\nreturn Dragdealer;\n\n}));\n"]},"hash":"6a78cf1163dcd784e224a24f3df6d3ff572c68b2"}
